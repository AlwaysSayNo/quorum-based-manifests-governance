version: "3"

vars:
  NAMESPACE: "controller-system"
  POD_LABEL: "control-plane=controller-manager"

  APP_NAME: "application-my"
  APP_NAMESPACE: "argocd"

  MRT_NAME: "mrt-my"
  MSR_NAME: "msr-my"
  MCA_NAME: "mca-my"
  WORK_NAMESPACE: "test-ns"

  TARGET_FILE: "app-manifests/nginx-deploy.yaml"
  TEMP_PIN_FILE: ".initial_pin"

env:
  HTTP_REPO_URL: "" #
  SSH_REPO_URL: "" #
  SLACK_CHANNEL_ID: "" #

tasks:
  0-setup:1-apply-governance-init:
    desc: "Apply the governance initialization manifest which sets up the repository and cluster for the scenario."
    cmds:
      - kubectl apply -f https://github.com/AlwaysSayNo/quorum-based-manifests-governance/releases/download/v1.0.1/install.yaml
      - kubectl wait --for=condition=ready pod --all -n controller-system --timeout=300s || true

  0-setup:2-start-governance:
    desc: "Push the MRT manifest to the remote repository and wait, trigger the ArgoCD sync and capture the initial pin."
    cmds:
      - |
        # Pushing MRT manifest to remote repository
        git add app-manifests/mrt.yaml
        git commit -m "Start Governance process"
        git push origin main
        sleep 10 # Wait until changes are in remote repository
      - |
        # Triggering ArgoCD sync and waiting for stabilization
        kubectl -n {{.APP_NAMESPACE}} patch application {{.APP_NAME}} --type=merge -p '{"operation":{"sync":{"prune":true,"syncStrategy":{"hook":{}}}}}'
        # Wait for the application to sync and stabilize
        sleep 120

  0-setup:3-verify-governance:
    desc: "Verify that governance resources are created and capture the initial ArgoCD pin."
    cmds:
      - |
        # Verify that all governance resources are created and in expected state
        kubectl get manifestrequesttemplate {{.MRT_NAME}} -n {{.WORK_NAMESPACE}}
        kubectl get manifestsigningrequest {{.MSR_NAME}} -n {{.WORK_NAMESPACE}}
        kubectl get manifestchangeapproval {{.MCA_NAME}} -n {{.WORK_NAMESPACE}}
      - |
        #Capturing initial ArgoCD pin for later comparison
        kubectl get application {{.APP_NAME}} -n {{.APP_NAMESPACE}} -o jsonpath='{.spec.source.targetRevision}' > {{.TEMP_PIN_FILE}}
        echo "Initial pin stored in {{.TEMP_PIN_FILE}}: $(cat {{.TEMP_PIN_FILE}})"
      - |
        #Pull the latest changes to ensure local repository is up to date
        git pull origin main

  1-malicious-changes:1-change-image:
    desc: "Modify the nginx image in the deployment manifest to a different version, simulating an unapproved change."
    cmds:
      - |
        # Simulating malicious modification
        sed -i 's|image: nginx:1.14.2|image: nginx:latest|g' {{.TARGET_FILE}}
        echo "Modifications applied locally:"
        grep "image:" {{.TARGET_FILE}}

  1-malicious-changes:2-commit-push:
    desc: "Commit and push the malicious changes to the remote repository."
    cmds:
      - |
        # Executing force bypass
        git add {{.TARGET_FILE}}
        git commit -m "Malicious update: Upgrade nginx without approval"
        git push -u origin main
        echo "Malicious commit pushed: $(git rev-parse HEAD)"

  2-verify-system:1-wait-detection:
    desc: "Wait until the controller detects the change and notifies governors."
    cmds:
      - |
        echo "Waiting for log message: 'History record added, ready to notify governors'..."
      - |
        # Stream logs with a timeout, searching for the specific success message.
        timeout 120s kubectl logs -f -n {{.NAMESPACE}} -l {{.POD_LABEL}} | \
        grep -m 1 "History record added, ready to notify governors" || \
        (echo "Failure: controller did not detect the change within given time." && exit 1)
        echo "Success: controller detected unapproved change and created MSR."

  3-verify-state:1-verify-no-update:
    desc: "Verify ArgoCD state was not updated and remains pinned to the initial commit."
    cmds:
      - |
        # Verifying ArgoCD state"
        INITIAL_PIN=$(cat {{.TEMP_PIN_FILE}})
        CURRENT_PIN=$(kubectl get application {{.APP_NAME}} -n {{.APP_NAMESPACE}} -o jsonpath='{.spec.source.targetRevision}')

        echo "Initial Pin: $INITIAL_PIN"
        echo "Current Pin: $CURRENT_PIN"

        # The current pin should match the initial pin.
        if [ "$CURRENT_PIN" = "$INITIAL_PIN" ]; then
          echo "Success: ArgoCD is still pinned to $CURRENT_PIN."
        else
          echo "Failure: ArgoCD updated to $CURRENT_PIN"
          exit 1
        fi

  4-cleanup:1-repo:
    desc: "Revert the scenario change, remove MRT file, and clean up repo state."
    cmds:
      - |
        rm -f {{.TEMP_PIN_FILE}} || true
      - |
        # Syncing repository
        git pull origin main

      - |
        # Revert the malicious change back to the setup state
        sed -i 's|image: nginx:latest|image: nginx:1.14.2|g' {{.TARGET_FILE}}

      - |
        # Remove the MRT file
        rm -f app-manifests/mrt.yaml

        # Governance folder should be already removed by the controller 
        # rm -rf app-manifests/.qubmango

      - |
        # Pushing cleanup commit
        git add app-manifests/mrt.yaml {{.TARGET_FILE}}
        git commit -m "Cleanup: Revert Threat 1 scenario" || true
        git push origin main

  4-cleanup:2-cluster:
    desc: "Delete the MRT from the cluster. ArgoCD will be automatically reset to track HEAD."
    cmds:
      - |
        # Deleting the MRT should trigger the controller to clean up associated MSR/MCA.
        kubectl delete manifestrequesttemplate {{.MRT_NAME}} -n {{.WORK_NAMESPACE}} --ignore-not-found --wait=true
        sleep 30

  4-cleanup:3-sync:
    desc: "Force ArgoCD to sync to the clean state."
    cmds:
      - |
        # Trigger a refresh and wait
        kubectl -n {{.APP_NAMESPACE}} annotate application {{.APP_NAME}} argocd.argoproj.io/refresh=normal --overwrite
        sleep 10

  4-cleanup:4-governance-init:
    desc: "Clean up the governance initialization from the cluster."
    cmds:
      - |
        kubectl delete -f https://github.com/AlwaysSayNo/quorum-based-manifests-governance/releases/download/v1.0.1/install.yaml --ignore-not-found --wait=true

  4-cleanup:5-restore-mrt:
    desc: "Restore the MRT manifest locally."
    cmds:
      - |
        # Restore the MRT file for the next scenario
        cp '../0. Setup/app-manifests/mrt.yaml' ./app-manifests/
      - |
        # Patch the mrt manifest with the correct SSH repo URL
        sed -i "s|SSH_REPO_URL_PLACEHOLDER|${SSH_REPO_URL}|g" app-manifests/mrt.yaml

        # Patch the mrt manifest with the correct Slack notification channel ID
        sed -i "s|SLACK_CHANNEL_ID_PLACEHOLDER|${SLACK_CHANNEL_ID}|g" app-manifests/mrt.yaml

        # Read the PGP public key from a file (assumed to be at ./secrets/pgp-public-key.asc)
        yq -i '.spec.pgp.publicKey = load_str("./secrets/pgp-public-key.asc")' app-manifests/mrt.yaml

        # Patch the mrt manifest with the correct owner public pgp key
        yq -i '.spec.governors.members[0].publicKey = load_str("./secrets/owner-pgp-public-key.asc")' app-manifests/mrt.yaml

        # Patch the mrt manifest with the correct voter1 public pgp key
        yq -i '.spec.governors.members[1].publicKey = load_str("./secrets/voter1-pgp-public-key.asc")' app-manifests/mrt.yaml

        # Patch the mrt manifest with the correct voter2 public pgp key
        yq -i '.spec.governors.members[2].publicKey = load_str("./secrets/voter2-pgp-public-key.asc")' app-manifests/mrt.yaml
